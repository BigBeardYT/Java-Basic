一、进程和线程
1. 在计算机中，我们将一个任务称为一个进程，比如浏览器、音乐播放器、IDEA等都是一个个的进程
某些进程内部还要执行多个子任务，例如，使用word时，我们可以一边打字，一边进行拼写检查，同时还可以后台打印，这种子任务就是线程
因此： 一个进程可以包含一个或多个线程，至少包含一个线程

2. 操作系统调度的基本单位是线程，而不是进程。常用的Windows、Linux等操作系统都采用抢占式多任务，如何调度线程完全由操作系统决定，程序自己不能决定什么时候执行，以及执行多长时间。

3. 同一个应用程序，既可以有多个进程，也可以有多个线程。

二、进程和线程的比较：
和多线程相比，多进程的缺点在于
    1. 创建进程比创建线程开销大，尤其是在Windows系统
    2. 进程间通信往往比线程间通信慢，因为线程是同写一个变量，速度很快
多进程优点：
    稳定性高，一个进程的崩溃不影响其他进程，而多线程中任何一个线程崩溃会直接导致整个进程崩溃

三、Java中的多线程
1. 一个Java程序本质上是一个JVM进程，JVM进程用一个主线程来执行 main() 方法，在main()的内部，我们又可以启动多个线程。此外，JVM还有负责垃圾回收的其他线程。
因此，对于大多数Java程序来说，我们说多任务，实际上就是说如何使用多线程实现多任务。

2. Java 多线程的特点
    * 多线程模型是 Java 程序最基本的并发模型
    * 后续读写网络、数据库、Web开发都以来Java的多线程

四、创建新线程
    1. Java语言内置了多线程支持。当Java程序启动的时候，实际上是启动了一个JVM进程，然后，JVM启动主线程来执行main()方法。在main()方法中，我们又可以启动其他线程。
        * 创建一个新线程非常容易，需要实例化一个 Thread 实例，然后调用它的 start() 方法
        public class Main {
            public static void main(String[] args) {
                Thread t = new Thread();
                t.start(); // 启动新线程
            }
        }
        * 但是这个线程启动后啥也没干就立刻结束了。我们希望线程能够执行指定的代码。有如下方法：
        方法一：从Thread派生一个自定义类，然后覆写run()方法
        class MyThread extends Thread {
            @Override
            public void run() {
                System.out.println("start my thread!");
            }
        }
        注意：直接调用 run() 方法是无效的，直接调用run()方法，相当于调用了一个普通的Java方法，当前线程并没有任何改变，也不会启动新线程。
             上述代码实际上是在main()方法内部又调用了run()方法，打印hello语句是在main线程中执行的，没有任何新线程被创建。

    2. 线程的优先级
        可以对线程设定优先级，设定优先级的方法是：Thread.setPriority(int n) // 1~10, 默认值5
        JVM自动把1（低）~10（高）的优先级映射到操作系统实际优先级上（不同操作系统有不同的优先级数量）。优先级高的线程被操作系统调度的优先级较高，
        操作系统对高优先级线程可能调度更频繁，但我们决不能通过设置优先级来确保高优先级的线程一定会先执行。

五、守护线程
    守护线程是指为其他线程服务的线程。在JVM中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。
    因此，JVM退出时，不必关心守护线程是否已结束。
    如何创建守护线程呢？方法和普通线程一样，只是在调用start()方法前，调用setDaemon(true)把该线程标记为守护线程：
        Thread t = new MyThread();
        t.setDaemon(true);
        t.start();
       在守护线程中，编写代码要注意：守护线程不能持有任何需要关闭的资源，例如打开文件等，因为虚拟机退出时，守护线程没有任何机会来关闭文件，这会导致数据丢失。


六、线程安全
    我们再思考一下，如果对一个静态方法添加synchronized修饰符，它锁住的是哪个对象？

    public synchronized static void test(int n) {
        ...
    }

    对于static方法，是没有this实例的，因为static方法是针对类而不是实例。但是我们注意到任何一个类都有一个由JVM自动创建的Class实例，
    因此，对static方法添加synchronized，锁住的是该类的Class实例。上述synchronized static方法实际上相当于：

    public class Counter {
        public static void test(int n) {
            synchronized(Counter.class) {
                ...
            }
        }
    }